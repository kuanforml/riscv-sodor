About The Sodor Processor Collection
====================================

Diagrams: [Sodor Github wiki](https://github.com/ucb-bar/riscv-sodor/wiki)

More documentation: [Librecores Sodor wiki](https://github.com/librecores/riscv-sodor/wiki)

Downstream development: [Librecores Sodor](https://github.com/librecores/riscv-sodor)


This repo has been put together to demonstrate a number of simple [RISC-V](http://riscv.org)
integer pipelines written in [Chisel](http://chisel.eecs.berkeley.edu):

* 1-stage (essentially an ISA simulator)
* 2-stage (demonstrates pipelining in Chisel)
* 3-stage (uses sequential memory; supports both Harvard and Princeton versions)
* 5-stage (can toggle between fully bypassed or fully interlocked)
* "bus"-based micro-coded implementation

All of the cores implement the RISC-V 32b integer base user-level ISA (RV32I)
version 2.0. None of the cores support virtual memory, and thus only implement
the Machine-level (M-mode) of the Privileged ISA v1.10 .

All processors talk to a simple scratchpad memory (asynchronous,
single-cycle), with no backing outer memory (the 3-stage is the exception
\- its scratchpad is synchronous). Programs are loaded in via a Debug Transport Module
 (DTM) described in [Debug Spec v0.13](https://static.dev.sifive.com/riscv-debug-spec-0.13.b4f1f43.pdf) port (while the core is kept in reset), effectively making the
scratchpads 3-port memories (instruction, data, debug).

This repository is set up to use the Verilog file generated by Chisel3 which is fed
to Verilator along with a test harness in C++ to generate and run the Sodor emulators.

This repo works great as an undergraduate lab (and has been used by Berkeley's
CS152 class for 3 semesters and counting). See doc/ for an example, as well as
for some processor diagrams. Be careful though - admittedly some of those
documents may become dated as things like the Privileged ISA evolve.



Getting the repo
================
```bash
git clone https://github.com/ucb-bar/riscv-sodor.git
cd riscv-sodor
git submodule update --init --recursive
```

Building the processor emulators
================================

Because this repository is designed to be used as RISC-V processor
examples written in [Chisel3](https://github.com/freechipsproject/chisel3/wiki) (and a regressive testsuite for Chisel updates),
no external [RISC-V tools](http://riscv.org) are used (with the exception of
the RISC-V [front-end server](https://github.com/codelec/riscv-fesvr) and
optionally, the [spike-dasm](https://github.com/riscv/riscv-isa-run) binary to
provide a disassembly of instructions in the generated *.out files).
The assumption is that [riscv-gnu-toolchain](https://github.com/riscv/riscv-gnu-toolchain) is not
available on the local system.  Thus, RISC-V unit tests and benchmarks were
compiled and committed to the sodor repository in the ./install directory (as are the .dump files).

Install verilator using any of the following possible ways
For Ubuntu 17.04
```bash
sudo apt install pkg-config verilator
#optionally gtkwave to view waveform dumps
```

For Ubuntu 16.10 and lower
```bash 
sudo apt install pkg-config
wget http://mirrors.kernel.org/ubuntu/pool/universe/v/verilator/verilator_3.900-1_amd64.deb
sudo dpkg -i verilator_3.900-1_amd64.deb
```

If you don't have enough permissions to use apt on your machine
```bash
# make autoconf g++ flex bison should be available
wget https://www.veripool.org/ftp/verilator-3.906.tgz
tar -xzf verilator-3.906.tgz
cd verilator-3.906
unset VERILATOR_ROOT
./configure
make
export VERILATOR_ROOT=$PWD
export PATH=$PATH:$VERILATOR_ROOT/bin
```

Install the RISC-V front-end server to talk between the host and RISC-V target processors.
```bash
cd riscv-fesvr
mkdir build; cd build
../configure --prefix=/usr/local
make install 
```

Build the sodor emulators
```bash
./configure --with-riscv=/usr/local
make
# To run the all the stages with the given tests available in ./install
make run-emulator
# To install the executables on the local system
make install
# Clean all generated files
make clean
```
(Although you can set the prefix to any directory of your choice, they must be
the same directory for both riscv-fesvr and riscv-sodor).

(Alternative) Build together with Chisel sources
------------------------------------------------

This repository packages [SBT](http://github.com/harrah/xsbt/wiki/Getting-Started-Setup)
(Scala Built Tool) for convenience.  By default SBT will fetch the Chisel
package specified in project/build.scala.

If you are a developer of Chisel and are using sodor cores to test your changes
to the Chisel repository, it is convenient to rebuild the Chisel package before
building the sodor cores. To do that, fetch the Chisel repo from github and pass 
the path to the local Chisel source directory to the configure script.

    $ git clone https://github.com/ucb-bar/chisel.git
    $ cd riscv-sodor
    $ ./configure --with-riscv=/usr/local --with-chisel=../chisel
    $ make


The riscv-test Collection
=========================

Sodor includes a submodule link to the "riscv-tests" repository. To help Sodor
users, the tests and benchmarks have been pre-compiled and placed in the
./install directory.

Building a RV32I Toolchain
--------------------------

If you would like to compile your own tests, you will need to build an
RV32I compiler. Set $RISCV to where you would like to install RISC-V related
tools, and make sure that $RISCV/bin is in your path.
```bash
git clone git@github.com:riscv/riscv-gnu-toolchain.git
cd riscv-gnu-toolchain
mkdir build; cd build
../configure --prefix=$RISCV --with-arch=rv32i
make install
```
This will install a compiler named riscv32-unknown-elf-gcc, complete with
newlib libraries that will only emit integer instructions. More advanced users
will want to consult the riscv-gnu-toolchain README regarding multilib support
for different base ISAs.

Compiling the tests yourself
----------------------------
```bash
    cd riscv-tests/isa
    make
```
This will compile ALL RISC-V assembly tests (32b and 64b). Sodor only supports
the rv32ui-p (user-level) and rv32mi-p (machine-level) physical memory tests.
```bash
    cd riscv-tests/benchmarks
    make
```
You will need to modify the Makefile in riscv-tests/benchmarks to compile RV32I
binaries.  By default, it will compile RV64G. If you compiled a pure RV32I
compiler, then you may only need to change the name of the compiler used
(riscv32-unknown-elf-gcc).  If your toolchain supports multiple ISAs, then you
may need to specify "-m32 --with-arch=RV32I" for the compiler and linker flags
as appropriate.


Hardware Emulation
----------------------------

First, you need to generate C emulator to run the pre-compiled benchmarks or your own custom benchmarks.

    $ make install
    $ cd emulator/rv32_1stage
   
You will see a binary executable "emulator" in the directory.

If you just want to run the pre-compiled benchmarks(i.e. provided by RISCV), type
    (run pre-compiled benchmarks)

    $ ./emulator +max-cycles=1000000 +loadmem=../../install/riscv-bmakrs/dhrystone.riscv none 
      3>&1 1>&2 2>&3 | ../common/tracer.py

You will see the emulation result and the tracer statistical information. Also, you can modify dhrystone.riscv to other .riscv files in "riscv-bmakrs"(i.e. c program benchmakrs) or "riscv-tests"(i.e. assembly benchmakrs).

Additionally, the emulation for your own custom banchmarks is also provided, which can be performed by running the .riscv files compiled by yourself instead of .riscv files provided by RISCV.
    (compiling custom benchmark)

    $ cd test/custom-bmarks
    
Then, after writing your own c programs in this directory, modify the Makefile

    PROGRAM=your_program_name

And type

    $ make clean
    $ make
The your_program_name.riscv(e.g. in this case, SHA256.riscv) will be generated.

    $ ./emulator +max-cycles=1000000 +loadmem=../../test/custom-bmarks/your_program_name.riscv none 
      3>&1 1>&2 2>&3 | ../common/tracer.py
Then, the simulation result will be generated.

(Optional)
You can also dump the assembly of the generated binary by typing

    $ riscv64-unknown-linux-gnu-objdump your_program_name.riscv --disassemble-all --disassemble-zeroes
      -section=.text --section=.data --section=.text.startup
